{"remainingRequest":"/home/wagner/FONTES/angular/angular-food-delivery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js??ref--8-1!/home/wagner/FONTES/angular/angular-food-delivery/node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js","dependencies":[{"path":"/home/wagner/FONTES/angular/angular-food-delivery/node_modules/rxjs/_esm5/internal/scheduler/AsyncScheduler.js","mtime":499162500000},{"path":"/home/wagner/FONTES/angular/angular-food-delivery/node_modules/cache-loader/dist/cjs.js","mtime":1539047243078},{"path":"/home/wagner/FONTES/angular/angular-food-delivery/node_modules/@angular-devkit/build-optimizer/src/build-optimizer/webpack-loader.js","mtime":1522755982000}],"contextDependencies":[],"result":["/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\n/** PURE_IMPORTS_START tslib,_Scheduler PURE_IMPORTS_END */\nimport * as tslib_1 from \"tslib\";\nimport { Scheduler } from '../Scheduler';\nvar AsyncScheduler = /*@__PURE__*/ (function (_super) {\n    tslib_1.__extends(AsyncScheduler, _super);\n    function AsyncScheduler() {\n        var _this = _super !== null && _super.apply(this, arguments) || this;\n        _this.actions = [];\n        /**\n         * A flag to indicate whether the Scheduler is currently executing a batch of\n         * queued actions.\n         * @type {boolean}\n         */\n        _this.active = false;\n        /**\n         * An internal ID used to track the latest asynchronous task such as those\n         * coming from `setTimeout`, `setInterval`, `requestAnimationFrame`, and\n         * others.\n         * @type {any}\n         */\n        _this.scheduled = undefined;\n        return _this;\n    }\n    AsyncScheduler.prototype.flush = function (action) {\n        var actions = this.actions;\n        if (this.active) {\n            actions.push(action);\n            return;\n        }\n        var error;\n        this.active = true;\n        do {\n            if (error = action.execute(action.state, action.delay)) {\n                break;\n            }\n        } while (action = actions.shift()); // exhaust the scheduler queue\n        this.active = false;\n        if (error) {\n            while (action = actions.shift()) {\n                action.unsubscribe();\n            }\n            throw error;\n        }\n    };\n    return AsyncScheduler;\n}(Scheduler));\nexport { AsyncScheduler };\n//# sourceMappingURL=AsyncScheduler.js.map\n",null]}